<!DOCTYPE html>
<html lang="en">
    <head>
        <script>window.WS_URL = "ws://localhost:8080";</script>
        <script src="/scripts/ws-control.js" defer></script>

    </head>
    <body>
       
        <!--<button id="previousZone">Zone Précédente</button>-->
        <div class="zone1" onclick="sendWS('sG_z1')">
            <div class="zone11" onclick="sendWS('sG_z1_1')">
            
            </div>
        </div>

        <!--<button id="previousZone">Zone Précédente</button>-->
        <div class="zone2" onclick="sendWS('sG_z2')">
            <div class="zone21" onclick="sendWS('sG_z2_1')">
                
            </div>
            <div class="zone22" onclick="sendWS('sG_z2_2')">
                
            </div>
            <div class="zone23" onclick="sendWS('sG_z2_2')">
                
            </div>
        </div>

        <!--<button id="previousZone">Zone Précédente</button>-->
        <div class="zone3" onclick="sendWS('sG_z3')">
            <div class="zone31" onclick="sendWS('sG_z3_1')">
                
            </div>
            <div class="zone32" onclick="sendWS('sG_z3_2')">
                
            </div>
        </div>

        <!-- Ajout du script qui défini les tailles des divs -->
        <script src="scripts/resizeZonesBateauGuillaume.js"></script>
        
    </body>

    <!-- Code à rajouter à chaque page-->
    <script>
        window.addEventListener('DOMContentLoaded', () => {
          console.log('sendWS =', typeof window.sendWS);
        });
      </script>
            <style>
              /* Bloquer clics sur toutes les zones sans overlay */
              div[class^="zone"]:not(.zone-has-overlay),
              div[class*=" zone"]:not(.zone-has-overlay) {
                pointer-events: none !important;
              }
              
              /* Zones reconnues par l’extension restent cliquables */
              div.zone-has-overlay {
                pointer-events: auto !important;
              }
              </style>
              <script>
                /* Stoppe les doubles clics sur zones superposées
                   en respectant l’extension qui toggle .zone-has-overlay */
                (function () {
                  const handlers = new WeakMap();
                
                  function arm(el) {
                    if (handlers.has(el)) return;
                    const h = (e) => {
                      // Laisse le onclick de CETTE zone s’exécuter,
                      // mais bloque la bulle vers les parents.
                      e.stopPropagation();
                    };
                    handlers.set(el, h);
                    el.addEventListener('click', h, false); // phase bulle
                  }
                
                  function disarm(el) {
                    const h = handlers.get(el);
                    if (!h) return;
                    el.removeEventListener('click', h, false);
                    handlers.delete(el);
                  }
                
                  function scan(root = document) {
                    root.querySelectorAll('.zone-has-overlay').forEach(arm);
                  }
                
                  const mo = new MutationObserver((muts) => {
                    for (const m of muts) {
                      if (m.type === 'attributes' && m.attributeName === 'class') {
                        const el = m.target;
                        if (!(el instanceof Element)) continue;
                        if (el.classList.contains('zone-has-overlay')) arm(el);
                        else disarm(el);
                      }
                      if (m.type === 'childList') {
                        m.addedNodes.forEach((n) => {
                          if (n.nodeType !== 1) return;
                          const el = /** @type {Element} */ (n);
                          if (el.classList?.contains('zone-has-overlay')) arm(el);
                          el.querySelectorAll?.('.zone-has-overlay').forEach(arm);
                        });
                        m.removedNodes.forEach((n) => {
                          if (n.nodeType !== 1) return;
                          const el = /** @type {Element} */ (n);
                          if (el.classList?.contains('zone-has-overlay')) disarm(el);
                          el.querySelectorAll?.('.zone-has-overlay').forEach(disarm);
                        });
                      }
                    }
                  });
                
                  mo.observe(document.documentElement, {
                    subtree: true,
                    childList: true,
                    attributes: true,
                    attributeFilter: ['class'],
                  });
                
                  if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => scan(), { once: true });
                  } else {
                    scan();
                  }
                })();
                </script>
              <style>
              /* debug visuel (optionnel) */
              .no-plugin-match { outline: 2px dashed rgba(255,0,0,.35); }
              </style>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            /* Ajout de l'image comme image de fond, sans répétition et centrée */
            background: url('images/BateauGuillaume.png') no-repeat center center fixed;
            /* "contain" permet d'avoir l'image qui est toujours entièrement visible peu importe la taille de la fenetre et sans déformation */
            background-size: contain;
        }
        div{
            font-size: 2%;/*la taille des textes est adapté à la taille de chaque zone */
        }
        .point {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            opacity: 1;
        }
        .img_zone1 {
            width: 100%;
            height: 100%;
            opacity: 0.2; /* rend l'image légèrement transparente pour pouvoir la placer correctement*/
            object-fit: cover;    /* ajuste l'image sans déformation, en recouvrant toute la zone */
            display: block;
            position: relative;
            overflow: visible; /* important *opacity: 0.2; /* rend l'image légèrement transparente pour pouvoir la placer correctement*/
            transform: translateY(-30px); /* monte l'image de quelques px paske elle etait trop basse, surement à ause du texte */
        }

        .img_zone2 {
            position: absolute; /* permet de sortir du flux */
            top: 0;
            left: -20px; /* décale vers la gauche */
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.2;
        }

        /* Style pour toutes les zones */
         .zone1, .zone11, .zone12, .zone13, .zone14, .zone141, .zone142, .zone2,  .zone21, .zone22, .zone23, .zone3 , .zone31,.zone32{
            position: absolute;
            box-sizing: border-box; /* Inclut la bordure dans la taille */
            /*border: 2px dashed red;
            background-color: rgba(255, 0, 0, 0.1);*/
        }
        /* Style pour les tests */
        .newZone, .zone213{
            position: absolute;
            /*border: 2px dashed blue;*/
            /*background-color: rgba(0, 0, 255, 0.1);*/
            box-sizing: border-box; /* Inclut la bordure dans la taille */
        }
        /* Style pour le bouton  */
        .nextScene {
        position: absolute;
        background-color: rgba(229, 229, 229, 0.381);
        color: grey;
        font-size: 120%;
        border: none;
        cursor: pointer;
    }
    
    </style>
</html>